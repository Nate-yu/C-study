# 2019 A

## 单选题

1. C语言规定，在一个源程序中，main函数的位置可以任意

2. ![image-20220925172313315](https://gitee.com/nate-yu/img-repository/raw/master/img/202209251726086.png)

   `sizeof(w*x+z-y) = 8 -> double. sizeof(int) = 4 or 2`

3. 有以下程序：

   ```c
   #include<stdio.h>
   int main()
   {
       int x = 3, y = 0, z = 0;
       if(x = y + z) printf("****");
       else printf("####");
       return 0;
   }
   ```

   输出结果：
   
   ```markdown
   ####
   解释：表达式“x = y + z”的值为0
   ```
   
4. 有以下程序：

   ```c
   #include<stdio.h>
   int main()
   {
       int x = 5;
       if(x-- < 5) printf("%d",x);
       else printf("%d",x++);
       return 0;
   }
   ```

   输出结果：

   ```markdown
   输出：4
   解释：分支结构执行的是“else”，“x--”与5进行比较时，是用5来跟5比较，比较完后再执行“--”操作，x变成   4。而执行else分支时，先执行输出，x输出为4，后执行“++”操作，最后x的值为5。
   ```

5. **switch** 语句中的 **expression** 是一个常量表达式，必须是一个**整型**或**枚举类型**

6. 二维数组可以不定义行数，但必须定义列数

   如：`char A[3][] = {"111","222"}`是错误的，而`char A[][3] = {"111","222"}`则为正确的

7. 返回值为void的函数，调用函数之后，被调用的函数没有返回值

8. 在以下说明语句中：

   ```c
   typedef struct
   {
       int a;
       char b;
       double c; 
   } Simple2;
   ```

   Simple2为结构体类型名，并未声明变量。但可以用Simple2作为类型声明新的结构体变量

9. 位运算中，操作数每右移一位，相当于操作数除以2；每左移以为，相当于操作数乘以2

10. C语言操作文件时，若执行fopen函数时发生错误，函数返回值为0

## 多选题

1. C程序可以由多个程序文件组成，可以由一个或多个函数组成，一个C函数可以单独作为一个C程序文件存在

2. 说明正确的程序：

   ```c
   char a[10] = "china";
   char a[10], *p = a; p = "china";
   char *a; a = "china";
   char a[10], *p; p = a;
   ```

3. `double a = b = 7;` 是错误的定义语句，报错：`b was not declared in this scoped`

4. 预处理命令可以放在程序中的任何位置，其有效范围从定义开始到文件结束。预处理命令有宏定义、文件包含和条件编译三类

## 填空题

1. 运算符优先级：`()` > `!` > `+` = `-` > `>>` = `<<` > `&&` > `||`

2. 将无符号八进制数字构成的字符串转换为十进制整数

   ```c
   #include<stdio.h>
   int main()
   {
       char *p,s[6];
       int n;
       p = s;
       gets(p);
       n = *p - '0'; // 将输入的八进制数字的第一位存入n
       while(*(++p) != '\0') { // 往后移动指针
           n = n*8 + *p - '\0';
       }
       printf("%d\n",n);
   }
   ```

## 程序分析题

1. 以下程序运行后的输出结果：

   ```c
   #include<stdio.h>
   int main()
   {
       char s[] = "9876", *p;
       for(p = s; p < s+2; p++) {
           printf("%s\n",p);
       }
       return 0;
   }
   ```

   结果：

   ```markdown
   9876
   876
   ```

2. 以下程序运行后的输出结果：

   ```c
   #include<stdio.h>
   int main()
   {
       char b[] = "Hello,you";
       b[5] = 0;
       printf("%s \n",b);
       return 0;
   }
   ```

   结果：

   ```markdown
   Hello
   b[5]=0；等价于b[5]=‘\0';
   ```

3. 以下程序运行后的输出结果：

   ```c
   #include<stdio.h>
   double sub(double x, double y, double z) {
       y -= 1.0;
       z = z + x;
       return z;
   }
   int main()
   {
       double a = 2.5, b = 9.0;
       printf("%f\n",sub(b-a,a,a));
       return 0;
   }
   ```

   结果：

   ```markdown
   9.000000
   类型：float
   ```

# 2019 B

## 单选题

1. C语言可执行程序的开始执行点是程序中的main函数

2. `'\o'`不是合法的字符常量

3. 能正确将c的值（c!=0）赋值给变量a、b的语句：`(a = c) && (b = c)`

4. 逻辑运算符两侧运算对象的数据类型可以是任何类型的数据

5. 对于`for(表达式1; ; 表达式3)`可以理解为：`for(表达式1; 1; 表达式3)`

6. 判断字符串s1是否大于字符串s2，应当使用`if(strcmp(s1, s2))`

7. C语言规定：实参可以是常量、变量或表达式，即可以为任何类型；形参应该与其对应的实参类型一致

8. 定义函数时，形参的类型说明可以放在函数体内

9. return后面的值可以为表达式

10. 如果函数值的类型与返回值类型不一致，以函数值类型为准

11. 实参与形参在类型上不一致时，若可以强制转换类型，则以形参为基准进行强转。否则实参和形参在数量上、类型上、顺序上应严格一致，

12. 以下程序：

    ```c
    void fun(int *a, int *b) {
        int *k;
        k = a;
        a = b;
        b = k;
    }
    
    int main()
    {
        int a = 3, b = 6, *x = &a, *y = &b;
        fun(x,y);
        printf("%d %d ",a,b);
    }
    ```

    输出结果：

    ```markdown
    3 6
    
    解释：
    	由于传入的实参是x和y的地址，所以实际上并没有改变变量a和变量b的值
    	只有直接将a和b的地址传入fun()函数中才能达到交换数值的效果
    ```

13. C语言结构体类型变量在程序执行期间所有成员一直驻留在内存中

14. 以下说明语句：

    ```c
    struct ex {
        int x;
        float y;
        char z;
    }example;
    ```

    其中，`struct`是结构体类型的关键字，`example`是结构体变量名，`x,y,z`都是结构体成员名，`struct ex`是结构体类型

15. fseek()函数正确调用形式：`fseek(文件类型指针, 位移量, 起始点)`

## 多选题

1. C语言中逻辑值“真”不能用`TRUE`表示
2. 在一个C源程序文件中，若要定义一个只允许本源文件中所用的函数的全局变量，变量只能使用`static`作为存储类别（注意：`auto`、`register`、`extern`均不行）

## 填空题

1. `pow(2.8, sqrt(double(x)))`值的数据类型为：double

2. 用$\frac{pai}{4}$ =  $(-1)^n\sum_{i=0}^n \frac{1}{2*i+1}$ 求pai的近似值

   ```c
   #include<stdio.h>
   #include<math.h>
   int main() 
   {
       int s = 1;;
       float n = 1.0,t = 1,pai = 0;
       while(fabs(t) >= 1e-6) {
           pai = pai + t;
           n = n + 2.0;
           s = -s;
           t = s/n;
       }
       pai = pai / 4;
       printf("%f",pai);
       return 0;
   }    
   ```

3. 求阶乘的累加和 S = $\sum_{i=0}^{n} i!$

   ```c
   #include<stdio.h>
   long f(int n) {
       long s = 1;
       for(int i = 1; i <= n; i++) {
           s = s*i;
       }
       return s;
   }
   
   int main()
   {
       long s;
       int n;
       scanf("%d",&n);
       s = 0;
       for(int i = 0; i <= n; i++) {
           s = s + f(i);
       }
       printf("s=%ld\n",s);
       return 0;
   }
   ```

## 程序分析

不开辟第三方变量而交换数据

```c
int main()
{
    int a = 3,b = 4;
    a = a^b;
    b = a^b;
    a = a^b;
    printf("%d %d",a,b);
    return 0;
}
```

# 2020 A



# 1 数据类型及其运算

1. 自增自减运算符不能作用于常量和表达式

2. 运算符优先级：算术 > 关系 > 逻辑

3. 实数（double、float）不能进行`++`运算

4. `*` > `+` > `+=`；`<<` > `^`

5. `short int i`表示65536：0；`short int i`表示65535：-1；`unsigned short int i`表示65535：65535

6. 判断是否是$2^n$(n>0)的表达式：`!(x&(x-1))`

   解释：因为2、4、8、...，这样的数转化为二进制后为：10、100、1000、...，如果x减1后与x做与运算，则结果为0，即x是$2^n$

7. 字符数据在内存中占一个字节

8. 自增、自减都是单目运算符

9. C语言中进行混合运算时，数据类型由低级向高级转换

10. 参加位运算的数据可以是整数或兼容的数据

11. `x = a++*a++*a++`等价于：`x = a*a*a; a++; a++; a++`； `y = --b*--b*--b`等价于：` --b; --b; --b; y = b*b*b;`

12. 以下程序：

    ```c
    int i = 2;
    printf("%d,%d",i++,i--);
    ```

    输出结果及解释：

    ```markdown
    输出：1,2
    解释：printf()语句中改变变量i的值，从右向左计算表达式的值，先执行i--，返回2，i=1，再执行i++，返回1，i=2
    ```

13. unsigned型变量的输入格式描述符只能用%d、%x、%o

14. scanf()中可以指定域宽，但不能规定小数点后的位数

15. “%e”是以指数形式输出实数数字部分小数位数6位

# 2 选择结构与循环控制

1. 有以下程序：

   ```c
   #include<stdio.h>
   int main(int argc, char const *argv[])
   {
   	int i = 1, j = 2, k = 3;
   	if(i++==1 && (++j==3||k++==3))
   		cout<<i<<j<<k;
   	return 0;
   }
   ```

   输出结果：

   ```markdown
   233
   原因：`k++==3`w
   ```
   
2. switch...case结构中条件表达式和常量表达式值都必须是整型或字符型，不允许是浮点型

3. 通常不要比较几个浮点数是否相等

# 3 数据类型、表达式、变量常量

  1. **实数型常量**：必须含有小数点，但看到`float f=1.;`是对的，系统会默认小数点后的值为0，即输出时为1.00000
   2. **八进制常量**：开头必定是**0**，且后面的数只能在0~7之间。如091就是错误的。
   3. **十六进制常量**：以**0x**或**0X**开头，在16进制中**不区分大小写**，即0x6与0X6等价。可包含字母ABCDEF或abcdef（11,12,13,14,15,16）。
   4. **指数型常量**：（底数为10），e与E等价，且e与E后面必须接**数字**，且必须为**整数**。如1.85e2。就是185。
   5. **字符常量**：只能是单引号（''），且如果里面是数字必须复合上面四条的规定。
   6. `j++`是赋值语句。
   7. C程序中的#include和#define行均不是C语句
   8. 除逗号运算符外，赋值运算符优先级最低

# 4 数组

1. 以下程序

   ```c
   #include <stdio.h>
   
   void fun(int a[][4],int b[4]) {
   	for(int i = 0; i < 4; ++i) {
   		b[i] = a[i][i];
   	}
   }
   
   int main(int argc, char const *argv[])
   {
   	int x[][4] = {{1,2,3},{4},{5,6,7,8},{9,10}},y[4];
   	fun(x,y);
   	for(int i = 0; i < 4; ++i) {
   		printf("%d,",y[i]);
   	}
   	printf("\n");
   	return 0; 
   }
   ```

   x二维数组中初始化之后的值如下：

   ```markdown
   1 2 3 0
   4 0 0 0
   5 6 7 8 
   9 10 0 0
   ```

   故将x数组对角线的元素赋值给y数组后的输出结果为：

   ```markdown
   1,0,7,0,
   ```
   
2. 对二维数组的初始化不能两个维的长度都省略

3. 二维数组初始化时，允许省略第一维长度来给二维赋初值，但不允许省略第二维的长度

4. 以下程序：

   ```c
   int main(int argc, char const *argv[])
   {
   	static int a[4][4] = {{1,3,5},{2,4,6},{3,5,7}};
   	for(int i = 0;i<4;++i){
   		for(int j=0;j<4;j++) {
   			cout<<a[i][j]<<" ";
   		}
   		cout<<endl;
   	}
   	return 0; 
   }
   ```

   输出结果：

   ```markdown
   1 3 5 0
   2 4 6 0
   3 5 7 0
   0 0 0 0
   
   注：未被赋值的数组元素默认赋值为0
   ```

5. 在数组定义后，不能再给数组整体赋值，比如以下错误操作：

   ```c
   int a[3];
   a[] = {1,2,3};
   ```

6. 二维数组元素在内存中也是顺序存放的，它们的地址是连续的

7. 不能在赋值语句中用赋值运算符“=”对字符数组整体赋值

8. gets()函数返回值是用于存放字符串的字符数组的首地址

# 5 指针

1. 将字符串形式的八进制数转换成十进制数

   ```c
   #include "header.h" // 自定义头文件
   /*将字符串形式的八进制数转换成十进制数*/
   int main(int argc, char const *argv[])
   {
   	int n;
   	char s[6],*p=s;
   	gets(p);
   	n = *p-'0';
   	while(*++p != '\0') {
   		n = n*8+*p-'0';
   	}
   	cout<<n<<endl;	
   	return 0; 
   }
   ```

2. 对于基类型相同的两个指针变量之间不能进行“+”运算

3. 不能给指针变量赋常量

4. 在未给指针变量指向任何存储空间之前，不能执行取数据操作与赋值操作

5. 已通过`q = NULL;`语句将q指针置为NULL时，不能再对q所指存储空间进行赋值

6. 指针变量可以初始化为NULL或一个地址

7. 可以在初始化时给字符数组整体赋值，但不能在初始化之后，直接给字符数组整体赋值

8. 假设有这样一个数组：`int a[5];`，则`&a+1 = sizeof(a) = a[4] + 1 = a[5]`（尽管a[5]不存在，但可以理解为返回元素a[4]之后的地址）

9. `*(&a[i]) = a[i]`，`p[i] = *(p+i) = a[i]`

10. 有以下程序：

    ```c
    int main() {
        char *p = "abcdefgh", *r;
        long *q;
        q = (long*) p;
        q++;
        r = (char*) q;
        printf("%s\n",r);
    }
    ```

    输出结果：

    ```markdown
    efgh
    
    解释：`q = (long*) p;`将p的地址赋给q，由于一个字符占一个字节，而一个long型数占4个字节，所以`q++`表示q指向下4个字符，即指向字符串的‘e’字符；`r = (char*) q;`将q的地址值赋给r，即r指向字符串的‘e’字符。
    ```

11. 设有一数组与指针：`a[m][n], *p = &a[0][0]`，则`a[i][j] = *(p + n*i + j)`

12. `int (*p)[4]`表示p是一个含有4列的二维数组的指针

13. 在二维数组中，若a为数组名，则a+i和*(a+i)同样表示此数组第i行的首地址，二者完全等价

14. 对变量a进行如下定义：

    1. `int *a[10]`：一个有10个指针的**数组**（指针数组），且a是一个常量而不是变量，不能对其赋值
    2. `int (*a)[10]`：一个指向有10个整型数据的数组的指针，**二维数组**
    3. `int (*a)(int)`：一个**指向函数的指针**，该函数有一个整型参数并返回一个整型数
    4. `int (*a[10])(int)`：一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数

15. `int *a[10]`与`int (*a)[10]`的区别：

    1. 定义`int *a[10]`中，由于运算符"[]"的优先级比"*"高，先结合为a[10]，说明a是一个数组，再与`int *`结合，表示该数组的每个元素是整型数的指针，所以这里a是一个指针数组
    2. 定义`int (*a)[10]`中，由于存在"()"先结合为(*a)，定义a是一个指针，再与`int [10]`结合，表示a是指含有10个元素的整型数组的指针

# 6 函数

1. 若只在主函数中对函数f进行声明，则只能在主函数中正确调用函数f；而若在主函数前对函数f进行声明，则在主函数和其后的其他函数中都可以正确调用函数f

2. 对于以下程序：

   ```c
   int fun(int a, int b) {
   	printf("a=%d,b=%d ",a,b);
   	return (a>b?a:b);
   }
   
   int main(int argc, char const *argv[])
   {
   	int i = 2, j = 5, k = 3, m;
   	m = fun(fun(i,j),fun(j,k));
   	printf("m=%d\n",m);
   	return 0; 
   }
   ```

   执行结果：

   ```markdown
   a=5,b=3 a=2,b=5 a=5,b=5 m=5
   
   解释：
   在执行`m = fun(fun(i,j),fun(j,k));`语句中，先计算fun(j,k)，后计算fun(i,j)
   ```

3. 函数定义不可嵌套，函数调用可以嵌套

4. 如果函数值的类型与return语句中表达式的值不一致，则以函数类型为基准

5. 全局变量的有效范围是从它定义开始到文件结束而不是整个文件；程序一开始执行，为定义的全局变量分配存储空间，直到程序运行结束才释放

6. 静态类别变量的生存周期贯穿于整个程序的运行时间

7. 函数中的自动变量可以赋初值，每调用一次，赋一次初值；在调用函数时，实参和对应形参在类型上只需赋值兼容；外部变量的隐含类别是extern；函数形参可以指定为register变量

8. 只有使用时才为该类型的变量分配内存的存储类别是：auto和register

9. 静态函数只能被同一源文件中的函数调用，不能被其他源文件中的函数调用

10. C语言中的函数只有extern和static两种存储类别说明符

11. 如果函数类型与返回值类型不一致，以函数类型为准；形参与实参类型不一致，编译时不会报错，执行时会报错

12. 函数形参的存储单元是动态分配的

13. 数组名作为函数的参数时，实参数组和形参数组共用相同的内存单元

# 7 结构体与共用体

1. 在程序中定义了一个结构体类型后，可以多次用它来定义具有该类型的变量
2. 在引用结构体成员时，只能对最低级（即基本数据类型）的成员进行赋值或存取操作或计算
3. 结构体数组可以在定义时进行初始化
4. 结构体类型不允许递归定义，但定义结构体指针不是递归定义
5. 结构体变量不会回传形参的值给实参，但结构体指针变量会回传
6. 一旦定义了一个共用体变量后，只能引用改变量中的任意成员，但不能引用该变量
7. 共用体变量不能作为函数参数，但共用体变量指针可以
8. 枚举元素只能说符号，其值只能是整数；枚举变量只能取对应枚举类型的枚举元素表中的元素；可以在定义枚举类型时对枚举元素进行初始化；枚举元素表中的元素有先后次序，可以进行比较
9. 设有以下枚举类型：`enum language {Basic = 3, Assembly, Ada = 100, COBOL, Fortran}`，则Assembly = 4, COBOL = 101, Fortran = 102
10. typedef可以声明各种类型名，但不能用来声明变量；并不能创建新的数据类型，只是给原有的类型去一个新的类型标识符

# 8 预编译处理和位段

1. 编译系统对宏命令是在对源程序中其他成分正式编译之前进行处理的

2. 预处理命令不是C语言文本的一部分，C语言文本不包括库函数和预处理命令

3. 宏替换仅是字符串的替换，并不进行语法检查

4. C语言提供的预处理命令：宏定义、文件包含、条件编译（注：不包括字符预处理）

5. 位段结构体成员声明的一般形式：`数据类型 成员名 : 整数`，其中，“数据类型”只能是unsigned，shor unsigned或int型，“整数”指出位段的长度

6. 位段结构体：

   ```c
   struct st
   {
       unsigned a : 10;
       unsigned b : 12;
       unsigned c : 2
   }x;
   ```

   结构体位段变量x的总长度为24位，即3个字节

7. 位段最大长度位16，大于16的话就会不能通过编译

8. 不允许位段跨越一个字的边界，如果一个字余下的空间不能容纳一个位段，则这个位段从相邻的下一个字的边界开始存放。由此在上一个字中留下来未用的空位，称为空穴

9. 位段可以没有名字，无名位段表示该空间不用

10. 位段只能作为结构体成员，不能作共用体成员

11. 位段没有地址，不能进行取地址“&”操作

12. 位段的长度不能大于机器字长度，也不能定义位段数组

13. 位段可以用整形格式符输出

14. 位段可以在数值表达式中引用，会被系统自动转换成int型

# 9 文件

1. 以文本方式打开一个文件输出时，将换行符转换成回车换行两个字符；而输入时，将回车换行符转换成一个换行符
2. 文件由字符序列组成
3. 写文件：将计算机内存中的信息存入磁盘；读文件：将磁盘中的信息读入计算机内存
4. 文件指针指向整个文件；文件内部的位置指针指示文件内部的当前读/写位置
5. fopen()函数发生错误时返回0
6. 顺利执行了文件关闭操作时，fclose()函数返回0
7. 读到文件末尾，feof(fp)返回非零值
8. fputc()函数输出字符成功时，返回输出的字符
9. fgets(s,n,f)功能：从文件f中读取长度不超过n-1的字符串存入指针s所指的内存中
10. fwrite()调用格式：fwrite(buffer,size,count,fp)
11. C语言中将文件视为无结构的字节流
12. 文件是一种流式文件，读写时均以字符为单位
13. `c=fgetc(fp)!=EOF`的功能是从fp指向的文件中读取字符，并判断文件是否结束

